// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");

var Curry = require("bs-platform/lib/js/curry.js");

var Queue = require("bs-platform/lib/js/queue.js");

var Caml_array = require("bs-platform/lib/js/caml_array.js");

var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var NotOpenChan = Caml_exceptions.create("Channel-Channel.NotOpenChan");

function close(chan) {
  chan[
  /* status */
  4] =
  /* Closed */
  0;
  return (
    /* () */
    0
  );
}

function cap(param) {
  return param[
  /* cap */
  0];
}

function default_transformer(x) {
  return x;
}

function make(cap, $staropt$star, param) {
  var transformer = $staropt$star !== undefined ? $staropt$star : default_transformer;
  return (
    /* record */
    [
    /* cap */
    cap,
    /* buf */
    Queue.create(
    /* () */
    0),
    /* transformer */
    transformer,
    /* receivers */
    Queue.create(
    /* () */
    0),
    /* status : Open */
    1]
  );
}

function slide(chan) {
  while (true) {
    var receivers = chan[
    /* receivers */
    3];
    var buf = chan[
    /* buf */
    1];

    if (Queue.is_empty(receivers) || Queue.is_empty(buf)) {
      return (
        /* () */
        0
      );
    } else {
      var match = Queue.peek(buf);
      var match$1 = Queue.peek(receivers);
      var match$2 = match[1][
      /* ok */
      0];

      if (match$2) {
        Queue.pop(buf);
        continue;
      } else {
        var match$3 = match$1[
        /* ok */
        0];

        if (match$3) {
          Queue.pop(receivers);
          continue;
        } else {
          var match$4 = Queue.pop(buf);
          var sender = match$4[1];
          var item = match$4[0];
          var receiver = Queue.pop(receivers);
          receiver[
          /* ok */
          0] = true;
          sender[
          /* ok */
          0] = true;
          sender[
          /* resolve */
          1](item);
          return receiver[
          /* resolve */
          1](item);
        }
      }
    }
  }

  ;
}

function check_statuses(arr) {
  return $$Array.fold_left(function (status, chan) {
    var match = chan[
    /* status */
    4];

    if (match) {
      return status;
    } else {
      return (
        /* Closed */
        0
      );
    }
  },
  /* Open */
  1, arr);
}

function deliver(arr, item) {
  return new Promise(function (resolve, reject) {
    var sender =
    /* record */
    [
    /* ok */
    false,
    /* resolve */
    resolve];
    var match = check_statuses(arr);

    if (match) {
      for (var i = 0, i_finish = arr.length - 1 | 0; i <= i_finish; ++i) {
        var chan = Caml_array.caml_array_get(arr, i);
        var buf = chan[
        /* buf */
        1];
        var cap = chan[
        /* cap */
        0];
        Promise.resolve(Curry._1(chan[
        /* transformer */
        2], item)).then(function (cap, buf, chan) {
          return function (transformed) {
            if (cap !== undefined) {
              if (cap > Queue.length(buf)) {
                resolve(transformed);
              }
            }

            Queue.push(
            /* tuple */
            [transformed, sender], chan[
            /* buf */
            1]);
            return Promise.resolve(slide(chan));
          };
        }(cap, buf, chan));
      }

      return (
        /* () */
        0
      );
    } else {
      return reject(NotOpenChan);
    }
  });
}

function put(chan, item) {
  return deliver(
  /* array */
  [chan], item);
}

function is_completed(param) {
  var status = param[
  /* status */
  4];

  if (status ===
  /* Closed */
  0) {
    return Queue.length(param[
    /* buf */
    1]) === 0;
  } else {
    return false;
  }
}

function take(chan) {
  return new Promise(function (resolve, reject) {
    Queue.push(
    /* record */
    [
    /* ok */
    false,
    /* resolve */
    resolve], chan[
    /* receivers */
    3]);
    return slide(chan);
  });
}

function take_or(chan, default_item) {
  if (is_completed(chan)) {
    return Promise.resolve(default_item);
  } else {
    return new Promise(function (resolve, reject) {
      Queue.push(
      /* record */
      [
      /* ok */
      false,
      /* resolve */
      resolve], chan[
      /* receivers */
      3]);
      return slide(chan);
    });
  }
}

function is_ready_to_take(param) {
  return Queue.length(param[
  /* buf */
  1]) > 0;
}

function oneof(arr) {
  return new Promise(function (resolve, reject) {
    var receiver =
    /* record */
    [
    /* ok */
    false,
    /* resolve */
    resolve];

    for (var i = 0, i_finish = arr.length - 1 | 0; i <= i_finish; ++i) {
      var chan = Caml_array.caml_array_get(arr, i);
      Queue.push(receiver, chan[
      /* receivers */
      3]);
      slide(chan);
    }

    return (
      /* () */
      0
    );
  });
}

function oneof_or(arr, default_item) {
  var h = function (_i, arr) {
    while (true) {
      var i = _i;

      if (i >= arr.length) {
        return undefined;
      } else if (is_ready_to_take(Caml_array.caml_array_get(arr, i))) {
        return i;
      } else {
        _i = i + 1 | 0;
        continue;
      }
    }

    ;
  };

  var match = h(0, arr);

  if (match !== undefined) {
    return take(Caml_array.caml_array_get(arr, match));
  } else {
    return Promise.resolve(default_item);
  }
}

exports.NotOpenChan = NotOpenChan;
exports.make = make;
exports.cap = cap;
exports.deliver = deliver;
exports.put = put;
exports.take = take;
exports.take_or = take_or;
exports.close = close;
exports.is_completed = is_completed;
exports.oneof = oneof;
exports.oneof_or = oneof_or;
/* No side effect */